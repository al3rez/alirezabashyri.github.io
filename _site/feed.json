{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Alireza Bashiri",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/04/09/service-objects-using-activemodel-and-simpledelegator",
            "title": "Service Objects with ActiveModel and SimpleDelegator",
            "summary": null,
            "content_text": "One of the worst practices in Ruby On Rails is to clutter the Gemfile to dobasics as authentication, authorization, validation, etc. considering thefact that they are practiced for so long and they can be accomplished using justthe batteries already included in Ruby On Rails; service objects are nodifferent for which developers often end up using different gems to do such asimple pattern.In the favour of simplicity and the fact that I never trust dependencies due to to the complexity they bring in I’ve been using ActiveModel andSimpleDelegator to apply service objects through a consistent interfaceacross the controllers as well as avoiding dependency clutter and here’s the results.Login caseLet’s consider a user logging in use case;&gt; Users can login with password and email&gt; Users cannot login with wrong password / emailSo we have 2 cases which we have to cover in our implementation to do that Iuse ActiveModel::Validations to validate the parameters I receive from thecontroller and using save method to keep interface consistency.class Login  include ActiveModel::Model  attr_accessor :email, :password, :user  validates :email, presence: true  validates :password, presence: true  validates :user, presence: {message: \"email or password is wrong\"}  def initialize(params)    super(params.require(:user).permit(:email, :password))    @user = User.find_by(email: email, status: :active)&amp;.authenticate(password)  end  def save    return if invalid?    # This will generate and refresh user's token and return it    Tokenizer.generate_and_refresh!(@user)  endendHere if no user found it will set @user variable to nil and user presencevalidation will handle the error which keep us from writing an error handlingpart except a message.And the controller would be like;class LoginController &lt; ApplicationController  skip_before_action :authenticate  INCLUDED = %i[positions]  def create    login = Login.new(params)    if (user = login.save)      render json: user, include: INCLUDED    else      render json: login, status: :bad_request    end  end  private  def serializer    UserSerializer  end  def user_params    params.require(:user).permit(:email, :password)  endendThis is already battle-tested in production and it works like a charm.Approval flowLet’s consider a use case that your flow needs to go through multiple approvalsand each approval stage has its own validations and business logic. There are alot of ways to handle this;ActiveRecord callbacksIt may seem simple solution but you have to write tons of conditions to avoidconflict between different use cases and hard to debug.Contextual validations with on: :contextThis works just fine but it’ll clutter your models with a lot of business logicwhich it needs to somewhere else and it’s hard to test and modify due toit’s coupled with your model. e.g.validate :order_is_picked_before_packing, on: :packingDecorators + State machinesState machines needs to be force-feed to developers as they make handling datalogic so convenient but to provide a good interface for your controllers youcannot treat state machine transitions or guard errors as you best bet youstill need something in-between which in this case is a decorator which giveyou best of both worlds validations, callbacks, separation of concern, easeof testing and etc. In our case we need some conditions are met before going toanother state so the uses cases are;&gt; MVPs cannot be approved before they're submitted&gt; MVPs cannot be approved more than once by same user&gt; MVPs cannot be approved unless they have enough approvals from different usersLet’s take look at the code;class ApprovedMvp &lt; SimpleDelegator  include ActiveModel::Validations  def save(user)    return unless valid?    if in_state?(:draft)      errors.add(:minimal_viable_product, \"it should be submitted first\")      return    end    if approvals.find_by(user: user)      errors.add(:minimal_viable_product, \"already been approved by user\")      return    else      approvals.create!(user: user)    end    if has_enough_approvals?      transition_to!(:approved)    else      super()    end  endendHere we populate a decorated MVP with contextual errors and pass it up to the controllerclass UseCases::MinimalViableProductsController &lt; ApplicationController  INCLUDED = UseCasesController::INCLUDED  include UseCaseScoped  def approve    result = ApprovedMvp.new(minimal_viable_product)    if result.save(@current_user)      render json: result.use_case, include: INCLUDED    else      render json: result    end  endIn which will be handled by a ErrorSerializer and a concern calledActsAsJSONAPI which I’ve written to handle different cases of serialization anderror handling without dependencies and a lot of complexity which you cancheckout here.ConclusionCodes that are written 50 years ago with zero-dependencies are working finetoday and the ones are written today with dependencies may not work tomorrow :)And don’t get me wrong I don’t mean to reinvent the wheel but don’t be afraidto build your own tool since each app has different needs and not allgems/libraries are going to fit yours. Bad cases that you should neverimplement by yourself except for practice is encryption or an premature abstraction (framework, etc) that’s takes your more than 1 day or 2.I hope you’ve enjoyed itQuestions? Email me at alirezabashiri@fastmail.comSorry I won’t add comment section to my blog here.",
            "content_html": "<p><img src=\"/serve.png\" alt=\"serve\" /></p><p>One of the worst practices in Ruby On Rails is to clutter the Gemfile to dobasics as authentication, authorization, validation, etc. considering thefact that they are practiced for so long and they can be accomplished using justthe batteries already included in Ruby On Rails; service objects are nodifferent for which developers often end up using different gems to do such asimple pattern.</p><p>In the favour of simplicity and the fact that I never trust dependencies due to to the complexity they bring in I’ve been using <code class=\"highlighter-rouge\">ActiveModel</code> and<code class=\"highlighter-rouge\">SimpleDelegator</code> to apply service objects through a consistent interfaceacross the controllers as well as avoiding dependency clutter and here’s the results.</p><h1 id=\"login-case\">Login case</h1><p>Let’s consider a user logging in use case;</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt; Users can login with password and email&gt; Users cannot login with wrong password / email</code></pre></div></div><p>So we have <em>2 cases</em> which we have to cover in our implementation to do that Iuse <code class=\"highlighter-rouge\">ActiveModel::Validations</code> to validate the parameters I receive from thecontroller and using <code class=\"highlighter-rouge\">save</code> method to keep interface consistency.</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Login</span>  <span class=\"kp\">include</span> <span class=\"no\">ActiveModel</span><span class=\"o\">::</span><span class=\"no\">Model</span>  <span class=\"nb\">attr_accessor</span> <span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">:password</span><span class=\"p\">,</span> <span class=\"ss\">:user</span>  <span class=\"n\">validates</span> <span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>  <span class=\"n\">validates</span> <span class=\"ss\">:password</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>  <span class=\"n\">validates</span> <span class=\"ss\">:user</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"p\">{</span><span class=\"ss\">message: </span><span class=\"s2\">\"email or password is wrong\"</span><span class=\"p\">}</span>  <span class=\"k\">def</span> <span class=\"nf\">initialize</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>    <span class=\"k\">super</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">.</span><span class=\"nf\">require</span><span class=\"p\">(</span><span class=\"ss\">:user</span><span class=\"p\">).</span><span class=\"nf\">permit</span><span class=\"p\">(</span><span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">:password</span><span class=\"p\">))</span>    <span class=\"vi\">@user</span> <span class=\"o\">=</span> <span class=\"no\">User</span><span class=\"p\">.</span><span class=\"nf\">find_by</span><span class=\"p\">(</span><span class=\"ss\">email: </span><span class=\"n\">email</span><span class=\"p\">,</span> <span class=\"ss\">status: :active</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">authenticate</span><span class=\"p\">(</span><span class=\"n\">password</span><span class=\"p\">)</span>  <span class=\"k\">end</span>  <span class=\"k\">def</span> <span class=\"nf\">save</span>    <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"n\">invalid?</span>    <span class=\"c1\"># This will generate and refresh user's token and return it</span>    <span class=\"no\">Tokenizer</span><span class=\"p\">.</span><span class=\"nf\">generate_and_refresh!</span><span class=\"p\">(</span><span class=\"vi\">@user</span><span class=\"p\">)</span>  <span class=\"k\">end</span><span class=\"k\">end</span></code></pre></div></div><p>Here if no user found it will set <code class=\"highlighter-rouge\">@user</code> variable to <code class=\"highlighter-rouge\">nil</code> and user presencevalidation will handle the error which keep us from writing an error handlingpart except a message.</p><p>And the controller would be like;</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">LoginController</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationController</span>  <span class=\"n\">skip_before_action</span> <span class=\"ss\">:authenticate</span>  <span class=\"no\">INCLUDED</span> <span class=\"o\">=</span> <span class=\"sx\">%i[positions]</span>  <span class=\"k\">def</span> <span class=\"nf\">create</span>    <span class=\"n\">login</span> <span class=\"o\">=</span> <span class=\"no\">Login</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"n\">login</span><span class=\"p\">.</span><span class=\"nf\">save</span><span class=\"p\">)</span>      <span class=\"n\">render</span> <span class=\"ss\">json: </span><span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"ss\">include: </span><span class=\"no\">INCLUDED</span>    <span class=\"k\">else</span>      <span class=\"n\">render</span> <span class=\"ss\">json: </span><span class=\"n\">login</span><span class=\"p\">,</span> <span class=\"ss\">status: :bad_request</span>    <span class=\"k\">end</span>  <span class=\"k\">end</span>  <span class=\"kp\">private</span>  <span class=\"k\">def</span> <span class=\"nf\">serializer</span>    <span class=\"no\">UserSerializer</span>  <span class=\"k\">end</span>  <span class=\"k\">def</span> <span class=\"nf\">user_params</span>    <span class=\"n\">params</span><span class=\"p\">.</span><span class=\"nf\">require</span><span class=\"p\">(</span><span class=\"ss\">:user</span><span class=\"p\">).</span><span class=\"nf\">permit</span><span class=\"p\">(</span><span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">:password</span><span class=\"p\">)</span>  <span class=\"k\">end</span><span class=\"k\">end</span></code></pre></div></div><p>This is already battle-tested in <em><strong>production</strong></em> and it works like a charm.</p><h2 id=\"approval-flow\">Approval flow</h2><p>Let’s consider a use case that your flow needs to go through multiple approvalsand each approval stage has its own validations and business logic. There are alot of ways to handle this;</p><h3 id=\"activerecord-callbacks\"><code class=\"highlighter-rouge\">ActiveRecord</code> callbacks</h3><p>It may seem simple solution but you have to write tons of conditions to avoidconflict between different use cases and hard to debug.</p><h3 id=\"contextual-validations-with-on-context\">Contextual validations with <code class=\"highlighter-rouge\">on: :context</code></h3><p>This works just fine but it’ll clutter your models with a lot of business logicwhich it needs to somewhere else and it’s hard to test and modify due toit’s coupled with your model. e.g.</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">validate</span> <span class=\"ss\">:order_is_picked_before_packing</span><span class=\"p\">,</span> <span class=\"ss\">on: :packing</span></code></pre></div></div><h3 id=\"decorators--state-machines\">Decorators + State machines</h3><p>State machines needs to be force-feed to developers as they make handling datalogic so convenient but to provide a good interface for your controllers youcannot treat state machine transitions or guard errors as you best bet youstill need something in-between which in this case is a <em>decorator</em> which giveyou best of both worlds <em>validations</em>, <em>callbacks</em>, separation of concern, easeof testing and etc. In our case we need some conditions are met before going toanother state so the uses cases are;</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt; MVPs cannot be approved before they're submitted&gt; MVPs cannot be approved more than once by same user&gt; MVPs cannot be approved unless they have enough approvals from different users</code></pre></div></div><p>Let’s take look at the code;</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">ApprovedMvp</span> <span class=\"o\">&lt;</span> <span class=\"no\">SimpleDelegator</span>  <span class=\"kp\">include</span> <span class=\"no\">ActiveModel</span><span class=\"o\">::</span><span class=\"no\">Validations</span>  <span class=\"k\">def</span> <span class=\"nf\">save</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span>    <span class=\"k\">return</span> <span class=\"k\">unless</span> <span class=\"n\">valid?</span>    <span class=\"k\">if</span> <span class=\"n\">in_state?</span><span class=\"p\">(</span><span class=\"ss\">:draft</span><span class=\"p\">)</span>      <span class=\"n\">errors</span><span class=\"p\">.</span><span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"ss\">:minimal_viable_product</span><span class=\"p\">,</span> <span class=\"s2\">\"it should be submitted first\"</span><span class=\"p\">)</span>      <span class=\"k\">return</span>    <span class=\"k\">end</span>    <span class=\"k\">if</span> <span class=\"n\">approvals</span><span class=\"p\">.</span><span class=\"nf\">find_by</span><span class=\"p\">(</span><span class=\"ss\">user: </span><span class=\"n\">user</span><span class=\"p\">)</span>      <span class=\"n\">errors</span><span class=\"p\">.</span><span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"ss\">:minimal_viable_product</span><span class=\"p\">,</span> <span class=\"s2\">\"already been approved by user\"</span><span class=\"p\">)</span>      <span class=\"k\">return</span>    <span class=\"k\">else</span>      <span class=\"n\">approvals</span><span class=\"p\">.</span><span class=\"nf\">create!</span><span class=\"p\">(</span><span class=\"ss\">user: </span><span class=\"n\">user</span><span class=\"p\">)</span>    <span class=\"k\">end</span>    <span class=\"k\">if</span> <span class=\"n\">has_enough_approvals?</span>      <span class=\"n\">transition_to!</span><span class=\"p\">(</span><span class=\"ss\">:approved</span><span class=\"p\">)</span>    <span class=\"k\">else</span>      <span class=\"k\">super</span><span class=\"p\">()</span>    <span class=\"k\">end</span>  <span class=\"k\">end</span><span class=\"k\">end</span></code></pre></div></div><p>Here we populate a decorated <code class=\"highlighter-rouge\">MVP</code> with contextual errors and pass it up to the controller</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">UseCases</span><span class=\"o\">::</span><span class=\"no\">MinimalViableProductsController</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationController</span>  <span class=\"no\">INCLUDED</span> <span class=\"o\">=</span> <span class=\"no\">UseCasesController</span><span class=\"o\">::</span><span class=\"no\">INCLUDED</span>  <span class=\"kp\">include</span> <span class=\"no\">UseCaseScoped</span>  <span class=\"k\">def</span> <span class=\"nf\">approve</span>    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"no\">ApprovedMvp</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">minimal_viable_product</span><span class=\"p\">)</span>    <span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">save</span><span class=\"p\">(</span><span class=\"vi\">@current_user</span><span class=\"p\">)</span>      <span class=\"n\">render</span> <span class=\"ss\">json: </span><span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">use_case</span><span class=\"p\">,</span> <span class=\"ss\">include: </span><span class=\"no\">INCLUDED</span>    <span class=\"k\">else</span>      <span class=\"n\">render</span> <span class=\"ss\">json: </span><span class=\"n\">result</span>    <span class=\"k\">end</span>  <span class=\"k\">end</span></code></pre></div></div><p>In which will be handled by a <code class=\"highlighter-rouge\">ErrorSerializer</code> and a concern called<code class=\"highlighter-rouge\">ActsAsJSONAPI</code> which I’ve written to handle different cases of serialization anderror handling without dependencies and a lot of complexity which you cancheckout <a href=\"https://github.com/Netflix/fast_jsonapi/issues/102#issuecomment-559920150\">here</a>.</p><h2 id=\"conclusion\">Conclusion</h2><p>Codes that are written 50 years ago with zero-dependencies are working finetoday and the ones are written today with dependencies may not work tomorrow :)</p><p>And don’t get me wrong I don’t mean to reinvent the wheel but don’t be afraidto build your own tool since each app has different needs and not allgems/libraries are going to fit yours. Bad cases that you <em>should</em> neverimplement by yourself except for practice is encryption or an premature abstraction (framework, etc) that’s takes your more than 1 day or 2.</p><p>I hope you’ve enjoyed it</p><p><br /></p><hr /><p><br />Questions? <em>Email me at alirezabashiri@fastmail.com</em><br /><em>Sorry I won’t add comment section to my blog here.</em></p>",
            "url": "http://localhost:4000/2020/04/09/service-objects-using-activemodel-and-simpledelegator",
            
            
            
            
            
            "date_published": "2020-04-09T00:02:00+07:00",
            "date_modified": "2020-04-09T00:02:00+07:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}